a. branch greater than
bgt r1, r2, L
if r1>r2, will branch to L
branch is relative, jump is absolute

r1 big then branch
slt t0 r2 r1 //r2 small than t0 = 1
bne t0 zero L 

b. branch greater than or equal 
bge r1, r2, L 
if r1 >= r2, branch to L 

r1 big or same as r2
slt t0 r1 r2 //r1 smaller then t0 will be 1
beq t0 zero L 

c. branch less than or equal
ble r1, r2, L 
r1 smaller or equal
slt t0 r2 r1 //if r2 is smaller then t0 will be 1
beq t0 zero L 

d. load immediate
$r, imm 
initialize a register with a constant value without needing 
to load it from memory or perform complex calculations

lui t0, 0xAAAA // upper bits is AAAA, lower bits is 0s
ori t0, t0, 0xF0F0 // lower bits will be set here

e. no operation
null operation
sll $zero, $zero, 0  
# shift $zero left by 0 bits (i.e., do nothing)

------------------------------------------------------------
q3. 
i. lw $24, 0($15)
op code = 23 hex = 100011
rt=24 = 11000
rs=15 = 1111

opcode rs rt imme
100011 01111 11000  (160)

3b. 
rr1=
rr2=
wr=
wd=
opr1=
opr2=
address=
write data=

regdst=0
regwr=1
alusrc=1
mrd=1
mwr=0
mtor=1
brch=0
aluop=0
alucontrol=0

ii. beq $1, $3, 12
op code = 4 hex = 000100
rs = 1 = 00001
rt = 3 = 00011
label = 12 = 1100

opcode rs rt imme
000100 00001 00011 (120)1100
000100 00001 00011 0000000000001100

The value of PC after the instruction is executed depends on 
whether the branch is taken or not. If the branch is taken, 
the value of PC is the target address of the branch, which is 
PC + 4 + (offset << 2), where offset is the signed 16-bit 
immediate value of the beq instruction. If the branch is not 
taken, the value of PC is the address of the next instruction, 
which is PC + 4.

3b. 
rr1=
rr2=
wr=
wd=
opr1=
opr2=
address=
write data=

regdst=0
regwr=0
alusrc=0
mrd=0
mwr=0
mtor=0
brch=0
aluop=0
alucontrol=1


iii. sub $25, $20, $5
opcode = 0/22hex = 000000/100010
rs = 25 = 11001
rt = 20 = 10100
rd = 5 = 101
shamt = 0
opcode rs rt rd shamt function
000000 11001 10100 00101 00000 100010

3b. 
rr1=
rr2=
wr=
wd=
opr1=
opr2=
address=
write data=

regdst=1
regwr=1
alusrc=0
mrd=0
mwr=0
mtor=0
brch=0
aluop=1
alucontrol=0





